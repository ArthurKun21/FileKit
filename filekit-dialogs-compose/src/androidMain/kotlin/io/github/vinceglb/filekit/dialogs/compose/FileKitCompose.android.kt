@file:OptIn(io.github.vinceglb.filekit.dialogs.FileKitDialogsInternalApi::class)

package io.github.vinceglb.filekit.dialogs.compose

import android.content.Context
import android.content.Intent
import android.net.Uri
import androidx.activity.compose.LocalActivityResultRegistryOwner
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.PickVisualMediaRequest
import androidx.activity.result.contract.ActivityResultContract
import androidx.activity.result.contract.ActivityResultContracts
import androidx.activity.result.contract.ActivityResultContracts.PickVisualMedia.ImageAndVideo
import androidx.activity.result.contract.ActivityResultContracts.PickVisualMedia.ImageOnly
import androidx.activity.result.contract.ActivityResultContracts.PickVisualMedia.VideoOnly
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberUpdatedState
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.platform.LocalInspectionMode
import androidx.core.net.toUri
import io.github.vinceglb.filekit.FileKit
import io.github.vinceglb.filekit.PlatformFile
import io.github.vinceglb.filekit.dialogs.FileKitAndroidDialogsInternal
import io.github.vinceglb.filekit.dialogs.FileKitDialogSettings
import io.github.vinceglb.filekit.dialogs.FileKitMode
import io.github.vinceglb.filekit.dialogs.FileKitOpenCameraSettings
import io.github.vinceglb.filekit.dialogs.FileKitPickerState
import io.github.vinceglb.filekit.dialogs.FileKitType
import io.github.vinceglb.filekit.dialogs.TakePictureWithCameraFacing
import io.github.vinceglb.filekit.dialogs.init
import io.github.vinceglb.filekit.dialogs.toAndroidUri
import io.github.vinceglb.filekit.path

internal const val PICKER_MODE_SINGLE = "single"
internal const val PICKER_MODE_MULTIPLE = "multiple"
internal const val PICKER_MODE_SINGLE_WITH_STATE = "single_with_state"
internal const val PICKER_MODE_MULTIPLE_WITH_STATE = "multiple_with_state"

private const val LAUNCHER_VISUAL_SINGLE = "visual_single"
private const val LAUNCHER_VISUAL_MULTIPLE = "visual_multiple"
private const val LAUNCHER_FILE_SINGLE = "file_single"
private const val LAUNCHER_FILE_MULTIPLE = "file_multiple"

@Composable
internal actual fun InitFileKit() {
    if (!LocalInspectionMode.current) {
        val registry = LocalActivityResultRegistryOwner.current?.activityResultRegistry

        // if null then MainActivity is not an Activity that implements ActivityResultRegistryOwner e.g. ComponentActivity
        // This should not generally happen
        // Calls to launcher should fail with FileKitNotInitializedException if it wasn't previously initialized
        LaunchedEffect(registry) {
            if (registry != null) {
                FileKit.init(registry)
            }
        }
    }
}

@Composable
internal actual fun <PickerResult, ConsumedResult> rememberPlatformFilePickerLauncher(
    type: FileKitType,
    mode: FileKitMode<PickerResult, ConsumedResult>,
    directory: PlatformFile?,
    dialogSettings: FileKitDialogSettings,
    onResult: (ConsumedResult) -> Unit,
): PickerResultLauncher {
    val currentType by rememberUpdatedState(type)
    val currentMode by rememberUpdatedState(mode)
    val currentOnConsumed by rememberUpdatedState(onResult)

    var pendingModeId by rememberSaveable { mutableStateOf<String?>(null) }
    var pendingMaxItems by rememberSaveable { mutableStateOf<Int?>(null) }
    var pendingLauncherId by rememberSaveable { mutableStateOf<String?>(null) }

    fun dispatchPendingResult(launcherId: String, files: List<PlatformFile>?) {
        if (pendingLauncherId != launcherId) return

        val modeId = pendingModeId ?: return

        dispatchPickerConsumedResult(
            modeId = modeId,
            maxItems = pendingMaxItems,
            files = files,
            onConsumed = { consumed ->
                @Suppress("UNCHECKED_CAST")
                currentOnConsumed(consumed as ConsumedResult)
            },
        )

        pendingModeId = null
        pendingMaxItems = null
        pendingLauncherId = null
    }

    val visualSingleLauncher = rememberLauncherForActivityResult(ActivityResultContracts.PickVisualMedia()) { uri ->
        dispatchPendingResult(
            launcherId = LAUNCHER_VISUAL_SINGLE,
            files = uri?.let { listOf(PlatformFile(it)) },
        )
    }

    val visualMultipleLauncher = rememberLauncherForActivityResult(DynamicPickMultipleVisualMediaContract()) { uris ->
        dispatchPendingResult(
            launcherId = LAUNCHER_VISUAL_MULTIPLE,
            files = uris.map(::PlatformFile),
        )
    }

    val fileSingleLauncher = rememberLauncherForActivityResult(ActivityResultContracts.OpenDocument()) { uri ->
        dispatchPendingResult(
            launcherId = LAUNCHER_FILE_SINGLE,
            files = uri?.let { listOf(PlatformFile(it)) },
        )
    }

    val fileMultipleLauncher = rememberLauncherForActivityResult(ActivityResultContracts.OpenMultipleDocuments()) { uris ->
        dispatchPendingResult(
            launcherId = LAUNCHER_FILE_MULTIPLE,
            files = uris.map(::PlatformFile),
        )
    }

    return remember(
        visualSingleLauncher,
        visualMultipleLauncher,
        fileSingleLauncher,
        fileMultipleLauncher,
    ) {
        PickerResultLauncher {
            val modeSnapshot = currentMode.toPendingModeSnapshot()
            pendingModeId = modeSnapshot.modeId
            pendingMaxItems = modeSnapshot.maxItems

            when (val pickerType = currentType) {
                FileKitType.Image,
                FileKitType.Video,
                FileKitType.ImageAndVideo,
                -> {
                    val request = when (pickerType) {
                        FileKitType.Image -> PickVisualMediaRequest(ImageOnly)
                        FileKitType.Video -> PickVisualMediaRequest(VideoOnly)
                        FileKitType.ImageAndVideo -> PickVisualMediaRequest(ImageAndVideo)
                    }

                    when {
                        modeSnapshot.isSingleMode() -> {
                            pendingLauncherId = LAUNCHER_VISUAL_SINGLE
                            visualSingleLauncher.launch(request)
                        }

                        else -> {
                            pendingLauncherId = LAUNCHER_VISUAL_MULTIPLE
                            visualMultipleLauncher.launch(
                                DynamicPickMultipleVisualMediaInput(
                                    request = request,
                                    maxItems = modeSnapshot.maxItems,
                                ),
                            )
                        }
                    }
                }

                is FileKitType.File -> {
                    val mimeTypes = FileKitAndroidDialogsInternal.getMimeTypes(pickerType.extensions)
                    when {
                        modeSnapshot.isSingleMode() -> {
                            pendingLauncherId = LAUNCHER_FILE_SINGLE
                            fileSingleLauncher.launch(mimeTypes)
                        }

                        else -> {
                            pendingLauncherId = LAUNCHER_FILE_MULTIPLE
                            fileMultipleLauncher.launch(mimeTypes)
                        }
                    }
                }
            }
        }
    }
}

/**
 * Creates and remembers a [PickerResultLauncher] for picking a directory.
 *
 * @param directory The initial directory. Supported on desktop platforms.
 * @param dialogSettings Platform-specific settings for the dialog.
 * @param onResult Callback invoked with the picked directory, or null if cancelled.
 * @return A [PickerResultLauncher] that can be used to launch the picker.
 */
@Composable
public actual fun rememberDirectoryPickerLauncher(
    directory: PlatformFile?,
    dialogSettings: FileKitDialogSettings,
    onResult: (PlatformFile?) -> Unit,
): PickerResultLauncher {
    // Init FileKit
    InitFileKit()

    val currentOnResult by rememberUpdatedState(onResult)
    val currentDirectory by rememberUpdatedState(directory)

    var hasPendingLaunch by rememberSaveable { mutableStateOf(false) }

    val launcher = rememberLauncherForActivityResult(ActivityResultContracts.OpenDocumentTree()) { treeUri ->
        if (!hasPendingLaunch) return@rememberLauncherForActivityResult

        hasPendingLaunch = false
        val platformDirectory = treeUri?.let(::PlatformFile)
        currentOnResult(platformDirectory)
    }

    return remember(launcher) {
        PickerResultLauncher {
            val initialUri = currentDirectory?.path?.toUri()
            hasPendingLaunch = true
            launcher.launch(initialUri)
        }
    }
}

@Composable
internal actual fun rememberPlatformFileSaverLauncher(
    dialogSettings: FileKitDialogSettings,
    onResult: (PlatformFile?) -> Unit,
): SaverResultLauncher {
    val currentOnResult by rememberUpdatedState(onResult)

    var hasPendingLaunch by rememberSaveable { mutableStateOf(false) }

    val launcher = rememberLauncherForActivityResult(CreateDocumentDynamicContract()) { uri ->
        if (!hasPendingLaunch) return@rememberLauncherForActivityResult

        hasPendingLaunch = false
        currentOnResult(uri?.let(::PlatformFile))
    }

    return remember(launcher) {
        SaverResultLauncher { suggestedName, extension, directory ->
            val normalizedExtension = FileKitAndroidDialogsInternal.normalizeFileSaverExtension(extension)
            val fileName = FileKitAndroidDialogsInternal.buildFileSaverSuggestedName(
                suggestedName = suggestedName,
                extension = normalizedExtension,
            )
            val mimeType = FileKitAndroidDialogsInternal.getMimeType(normalizedExtension)

            hasPendingLaunch = true
            launcher.launch(
                CreateDocumentInput(
                    mimeType = mimeType,
                    fileName = fileName,
                ),
            )
        }
    }
}

/**
 * Creates and remembers a [PhotoResultLauncher] for taking a picture or video with the camera.
 *
 * @param openCameraSettings Platform-specific settings for the camera.
 * @param onResult Callback invoked with the saved file, or null if cancelled.
 * @return A [PhotoResultLauncher] that can be used to launch the camera.
 */
@Composable
public actual fun rememberCameraPickerLauncher(
    openCameraSettings: FileKitOpenCameraSettings,
    onResult: (PlatformFile?) -> Unit,
): PhotoResultLauncher {
    // Init FileKit
    InitFileKit()

    // Store the destination file URI string to survive process death.
    // If the user launches again before a callback, latest launch wins.
    var pendingDestinationUri by rememberSaveable { mutableStateOf<String?>(null) }

    // Updated callback
    val currentOnResult by rememberUpdatedState(onResult)

    // Create a stable contract instance (reused across recompositions)
    val contract = remember { TakePictureWithCameraFacing() }

    // Create the launcher using the Activity Result API
    val launcher = rememberLauncherForActivityResult(contract) { success ->
        val pendingUri = pendingDestinationUri ?: return@rememberLauncherForActivityResult
        pendingDestinationUri = null
        currentOnResult(resolveCameraResult(success, pendingUri))
    }

    // Return the PhotoResultLauncher wrapper
    return remember(launcher, contract) {
        PhotoResultLauncher { type, cameraFacing, destinationFile ->
            // Store the destination URI for retrieval after potential activity recreation
            val uri = destinationFile.toAndroidUri(openCameraSettings.authority)
            pendingDestinationUri = uri.toString()

            // Set the camera facing on the contract before launching
            contract.setCameraFacing(cameraFacing)

            // Launch the camera
            launcher.launch(uri)
        }
    }
}

internal fun resolveCameraResult(
    success: Boolean,
    pendingDestinationUri: String?,
): PlatformFile? {
    val uri = pendingDestinationUri ?: return null
    return if (success) PlatformFile(uri.toUri()) else null
}

private data class PendingModeSnapshot(
    val modeId: String,
    val maxItems: Int?,
)

private fun PendingModeSnapshot.isSingleMode(): Boolean =
    modeId == PICKER_MODE_SINGLE || modeId == PICKER_MODE_SINGLE_WITH_STATE

private fun <PickerResult, ConsumedResult> FileKitMode<PickerResult, ConsumedResult>.toPendingModeSnapshot(): PendingModeSnapshot =
    when (this) {
        FileKitMode.Single -> PendingModeSnapshot(PICKER_MODE_SINGLE, null)
        is FileKitMode.Multiple -> PendingModeSnapshot(PICKER_MODE_MULTIPLE, maxItems)
        FileKitMode.SingleWithState -> PendingModeSnapshot(PICKER_MODE_SINGLE_WITH_STATE, null)
        is FileKitMode.MultipleWithState -> PendingModeSnapshot(PICKER_MODE_MULTIPLE_WITH_STATE, maxItems)
    }

internal fun dispatchPickerConsumedResult(
    modeId: String,
    maxItems: Int?,
    files: List<PlatformFile>?,
    onConsumed: (Any?) -> Unit,
) {
    val states = files.toPickerStates()

    when (modeId) {
        PICKER_MODE_SINGLE -> {
            val result = when (val lastState = states.last()) {
                is FileKitPickerState.Completed -> lastState.result.firstOrNull()
                else -> null
            }
            onConsumed(result)
        }

        PICKER_MODE_MULTIPLE -> {
            val result = when (val lastState = states.last()) {
                is FileKitPickerState.Completed -> {
                    maxItems?.let { max -> lastState.result.take(max) } ?: lastState.result
                }

                else -> {
                    null
                }
            }
            onConsumed(result)
        }

        PICKER_MODE_SINGLE_WITH_STATE -> {
            states.forEach { state ->
                when (state) {
                    is FileKitPickerState.Cancelled -> {
                        onConsumed(FileKitPickerState.Cancelled)
                    }

                    is FileKitPickerState.Started -> {
                        onConsumed(FileKitPickerState.Started(total = state.total))
                    }

                    is FileKitPickerState.Progress -> {
                        val file = state.processed.firstOrNull()
                        if (file != null) {
                            onConsumed(
                                FileKitPickerState.Progress(
                                    processed = file,
                                    total = state.total,
                                ),
                            )
                        }
                    }

                    is FileKitPickerState.Completed -> {
                        val file = state.result.firstOrNull()
                        if (file != null) {
                            onConsumed(FileKitPickerState.Completed(result = file))
                        } else {
                            onConsumed(FileKitPickerState.Cancelled)
                        }
                    }
                }
            }
        }

        PICKER_MODE_MULTIPLE_WITH_STATE -> {
            states.forEach { state ->
                when (state) {
                    is FileKitPickerState.Cancelled -> {
                        onConsumed(FileKitPickerState.Cancelled)
                    }

                    is FileKitPickerState.Started -> {
                        onConsumed(
                            FileKitPickerState.Started(
                                total = maxItems?.let { max -> minOf(state.total, max) } ?: state.total,
                            ),
                        )
                    }

                    is FileKitPickerState.Progress -> {
                        onConsumed(
                            FileKitPickerState.Progress(
                                processed = maxItems?.let { max -> state.processed.take(max) } ?: state.processed,
                                total = maxItems?.let { max -> minOf(state.total, max) } ?: state.total,
                            ),
                        )
                    }

                    is FileKitPickerState.Completed -> {
                        onConsumed(
                            FileKitPickerState.Completed(
                                result = maxItems?.let { max -> state.result.take(max) } ?: state.result,
                            ),
                        )
                    }
                }
            }
        }
    }
}

internal fun List<PlatformFile>?.toPickerStates(): List<FileKitPickerState<List<PlatformFile>>> {
    val files = this
    return when {
        files.isNullOrEmpty() -> listOf(FileKitPickerState.Cancelled)

        else -> buildList {
            add(FileKitPickerState.Started(total = files.size))
            files.forEachIndexed { index, _ ->
                add(
                    FileKitPickerState.Progress(
                        processed = files.subList(0, index + 1),
                        total = files.size,
                    ),
                )
            }
            add(FileKitPickerState.Completed(result = files))
        }
    }
}

private data class DynamicPickMultipleVisualMediaInput(
    val request: PickVisualMediaRequest,
    val maxItems: Int?,
)

private class DynamicPickMultipleVisualMediaContract : ActivityResultContract<DynamicPickMultipleVisualMediaInput, List<Uri>>() {
    override fun createIntent(context: Context, input: DynamicPickMultipleVisualMediaInput): Intent {
        val delegate = input.maxItems
            ?.let { ActivityResultContracts.PickMultipleVisualMedia(it) }
            ?: ActivityResultContracts.PickMultipleVisualMedia()
        return delegate.createIntent(context, input.request)
    }

    override fun parseResult(resultCode: Int, intent: Intent?): List<Uri> = ActivityResultContracts.PickMultipleVisualMedia().parseResult(
        resultCode,
        intent,
    )
}

private data class CreateDocumentInput(
    val mimeType: String,
    val fileName: String,
)

private class CreateDocumentDynamicContract : ActivityResultContract<CreateDocumentInput, Uri?>() {
    override fun createIntent(
        context: Context,
        input: CreateDocumentInput,
    ): Intent = ActivityResultContracts.CreateDocument(input.mimeType).createIntent(context, input.fileName)

    override fun parseResult(resultCode: Int, intent: Intent?): Uri? = ActivityResultContracts
        .CreateDocument(
            "*/*",
        ).parseResult(resultCode, intent)
}
